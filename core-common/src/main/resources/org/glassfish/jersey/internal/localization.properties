#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2012-2017 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://oss.oracle.com/licenses/CDDL+GPL-1.1
# or LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#


# {0} - full classname
autodiscoverable.configuration.failed=Configuration of {0} auto-discoverable failed.
cache.control.is.null=Cache control is null.
committing.stream.already.initialized=Stream provider has already been initialized.
committing.stream.buffering.illegal.state=Cannot setup buffering as bytes have already been written to the output stream. The entity buffering can be initialized only before first bytes are written to the entity output stream.
component.cannot.be.null=Registered component instance cannot be null.
component.class.cannot.be.null=Registered component class cannot be null.
component.type.already.registered=Cannot create new registration for component type {0}: Existing previous registration found for the type.
component.contracts.empty.or.null=Attempt to register component of type {0} to null or empty array of contracts  is ignored.
configuration.not.modifiable=The configuration is not modifiable in this context.
contract.not.assignable=Contract {0} can not be registered for component {1}: Contract not assignable to component.
contract.not.supported=Contract {0} can not be registered for component {1}: Contract type not supported.
cookie.is.null=Cookie is null.
date.is.null=Date is null.
dependent.class.of.provider.format.error={0}. A dependent class of the class {1} implementing the provider {2} is malformed. The provider implementation is ignored. Check if the malformed class is part of a stubbed jar that used for compiling only.
dependent.class.of.provider.not.found=A dependent class, {0}, of the class {1} implementing the provider {2} is not found. The provider implementation is ignored.
entity.tag.is.null=Entity tag is null.
error.caught.while.loading.spi.providers=Error caught while loading SPI providers.
error.entity.stream.closed=Entity input stream has already been closed.
error.entity.provider.basictypes.character.morechars=A single character expected in the entity input stream.
error.entity.provider.basictypes.constructor=Error converting entity to {0} type by single String constructor.
error.entity.provider.basictypes.unkwnown=Unsupported basic type {0}.
error.finding.exception.mapper.type=Could not find exception type for given ExceptionMapper class: {0}.
error.interceptor.reader.proceed=Last reader interceptor in the chain called the method proceed.
error.interceptor.writer.proceed=Last writer interceptor in the chain called the method proceed.
error.mbr.isreadable=MesssageBodyReader {0} threw exception in isReadable - skipping.
error.mbw.iswritable=MesssageBodyWriter {0} threw exception in isWritable - skipping.
# {0} - Arbitrary localized message, e.g.: [NONFATAL] <localized_message>; source=<object>
error.msg=WARNING: {0}
error.newcookie.expires=NewCookie Expires header value ({0}) cannot be read.
error.notfound.messagebodywriter=MessageBodyWriter not found for media type={0}, type={1}, genericType={2}.
error.notfound.messagebodyreader=MessageBodyReader not found for media type={0}, type={1}, genericType={2}.
error.parsing.entity.tag=Error parsing entity tag: {0}
error.provider.constrainedTo.wrong.package=A registered provider {0} is constrained (via @ConstrainedTo) to {1} runtime but does not implement any provider interface usable in the runtime.
error.provider.constrainedTo.wrong.runtime=A provider {0} registered in {2} runtime is constrained (via @ConstrainedTo) to {1} runtime.
error.provider.and.resource.constrainedTo.ignored=Due to constraint configuration problems the implementations of providers in the resource class {0} will be ignored. However, the resource class will be loaded and used as an resource.
error.provider.constrainedTo.ignored=Due to constraint configuration problems the provider {0} will be ignored.
error.provider.registered.wrong.runtime=A provider {0} registered in {1} runtime does not implement any provider interfaces applicable in the {1} runtime.
error.reading.entity.from.input.stream=Error reading entity from input stream.
error.reading.entity.missing=Missing entity.
error.resolving.generic.type.value=Unable to resolve generic type value of {0} for an instance of {1}.
error.service.locator.provider.instance.feature.context=Incorrect type of feature context instance {0}. Parameter must be a default Jersey FeatureContext implementation.
error.service.locator.provider.instance.feature.writer.interceptor.context=Incorrect type of writer interceptor context instance {0}. Parameter must be a default Jersey WriterInterceptorContext implementation.
error.service.locator.provider.instance.feature.reader.interceptor.context=Incorrect type of reader interceptor context instance {0}. Parameter must be a default Jersey ReaderInterceptorContext implementation.
error.template.parser.illegal.char.after.name=Illegal character "{0}" at position {1} is not allowed after a name in a path template "{2}".
error.template.parser.illegal.char.partOf.name=Illegal character "{0}" at position {1} is not allowed as a part of a name in a path template "{2}".
error.template.parser.illegal.char.start.name=Illegal character "{0}" at position {1} is not allowed as a start of a name in a path template "{2}".
error.template.parser.invalid.syntax=Invalid syntax for the expression "{0}" associated with the name "{1}" in a path template "{2}".
error.template.parser.invalid.syntax.terminated=Invalid syntax in the template "{0}". Check if a path parameter is terminated with a "}".
error.template.parser.name.more.than.once=The name "{0}" is declared more than once with different regular expressions in a path template "{1}".
# {0} - List of localized messages, e.g.: [FATAL] <localized_message>; source=<object>
errors.and.warnings.detected=Following issues have been detected: {0}
exception.caught.while.loading.spi.providers=Exception caught while loading SPI providers.
exception.mapper.supported.type.unknown=Unable to retrieve the supported exception type for a registered exception mapper service class "{0}".
feature.has.already.been.processed=Feature [{0}] has already been processed.
hint.msg=HINT: {0}
hints.detected=The following hints have been detected: {0}
http.header.comments.not.allowed=Comments are not allowed.
http.header.end.of.header=End of header.
http.header.no.chars.between.separators=No characters between the separators "{0}" and "{1}".
http.header.no.end.separator=No end separator "{0}".
http.header.unbalanced.comments=Unbalanced comments.
http.header.unbalanced.quoted=Unbalanced quoted string.
http.header.whitespace.not.allowed=White space not allowed.
ignored.executor.providers=Multiple ExecutorServiceProvider registrations found for qualifier annotation [{1}]. The following provider registrations will be ignored: [{0}]
ignored.scheduler.providers=Multiple ScheduledExecutorServiceProvider registrations found for qualifier annotation [{1}]. The following provider registrations will be ignored: [{0}]
illegal.config.syntax=Illegal configuration-file syntax.
illegal.initial.capacity=Illegal initial capacity: {0}.
illegal.load.factor=Illegal load factor: {0}.
illegal.provider.class.name=Illegal provider-class name: {0}.
injection.error.suitable.constructor.not.found=Could not find a suitable constructor in {0} class.
injection.error.local.class.not.supported=Cannot instantiate {0} class. Instantiation of local classes is not supported.
injection.error.nonstatic.member.class.not.supported=Cannot instantiate {0} class. Instantiation of non-static member classes is not supported.
injection.manager.factory.not.found=InjectionManagerFactory not found.
injection.manager.not.provided=InjectionManager is not provided.
injection.manager.strategy.not.supported=InjectionManagerStrategy is not supported: {0}.
input.stream.closed=Input stream has been closed.
invalid.host=Invalid host name.
invalid.port=Invalid port value.
invalid.spi.classes=Supplied provider class(es) do not implement the expected {0} SPI: [{1}]
link.is.null=Link is null.
locale.is.null=Locale is null.
matrix.param.null=One or more of matrix value parameters are null.
# {0} - class name
mbr.trying.to.close.stream=Message body reader ({0}) is trying to close the entity input stream. Not closing.
# {0} - class name
mbw.trying.to.close.stream=Message body writer ({0}) is trying to close the entity output stream. Not closing.
media.type.is.null=Media type is null.
message.content.buffering.failed=Failed to buffer the message content input stream.
message.content.input.stream.close.failed=Error closing message content input stream.
message.content.buffer.reset.failed=Error resetting the buffered message content input stream.
method.not.getter.nor.setter=Method is neither getter nor setter.
multiple.matching.constructors.found=Found {0} constructors with {1} parameters in {2} class. Selecting the first found constructor: {3}
new.cookie.is.null=New cookie is null.
no.container.available=No container available.
no.error.processing.in.scope=There is no error processing in scope.
not.supported.on.outbound.message=Method not supported on an outbound message.
osgi.registry.error.opening.resource.stream=Unable to open an input stream for resource {0}.
osgi.registry.error.processing.resource.stream=Unexpected error occurred while processing resource stream {0}.
output.stream.closed=The output stream has already been closed.
overriding.method.cannot.be.found=Method that overrides {0} cannot be found on class {1}.
param.null="{0}" parameter is null.
# {0} - value to string; {1} - type of value; {2} - desired value type/class
properties.helper.get.value.no.transform=There is no way how to transform value "{0}" [{1}] to type [{2}].
properties.helper.deprecated.property.name=Deprecated property name "{0}" usage was found. Please use "{1}" instead.
provider.class.could.not.be.loaded=The class {0} implementing provider {1} could not be loaded: {2}
provider.could.not.be.created=The class {0} implementing provider {1} could not be instantiated: {2}
provider.not.found=The class {0} implementing the provider {1} is not found. The provider implementation is ignored.
query.param.null=One or more of query value parameters are null.
response.closed=Response is closed.
# {0} - fully qualified name of connector class; {1} - header names
some.headers.not.sent=There are some request headers that have not been sent by connector [{0}]. Probably you added \
those headers in WriterInterceptor or MessageBodyWriter. That feature is not supported by the connector. Please, \
do not modify headers in WriterInterceptor or MessageBodyWriter or use default HttpUrlConnector instead.\n\
Unsent header changes: {1}
slow.subscriber=Slow Subscriber. Subscription will be canceled. Item {0} and all the items sent after will not be received.
ssl.ctx.algorithm.not.supported=Error creating SSL context (algorithm not supported).
ssl.ctx.init.failed=Error initializing SSL context (operation failed).
ssl.ks.cert.load.error=Cannot load key store certificates.
ssl.ks.file.not.found=Cannot find key store file "{0}".
ssl.ks.impl.not.found=Error initializing key store (implementation not available).
ssl.ks.integrity.algorithm.not.found=Error initializing key store (algorithm to check key store integrity not found).
ssl.ks.load.error=Error loading key store from file "{0}".
ssl.ks.providers.not.registered=Error initializing key store (provider not registered).
ssl.kmf.algorithm.not.supported=Error initializing key manager factory (algorithm not supported).
ssl.kmf.init.failed=Error initializing key manager factory (operation failed).
ssl.kmf.unrecoverable.key=Error initializing key manager factory (unrecoverable key).
ssl.kmf.no.password.set=Neither key password nor key store password has been set for {0} key store. \
  Ignoring the key store configuration and skipping the key manager factory initialization. \
  Key manager factory will not be configured in the current SSL context.
ssl.kmf.no.password.for.provider.based.ks="provider based"
ssl.kmf.no.password.for.byte.based.ks="byte array based"
ssl.kmf.provider.not.registered=Error initializing key manager factory (provider not registered).
ssl.ts.cert.load.error=Cannot load trust store certificates.
ssl.ts.file.not.found=Cannot find trust store file "{0}".
ssl.ts.impl.not.found=Error initializing trust store (implementation not available).
ssl.ts.integrity.algorithm.not.found=Error initializing trust store (algorithm to check trust store integrity not found).
ssl.ts.load.error=Error loading trust store from file "{0}".
ssl.ts.providers.not.registered=Error initializing trust store (provider not registered).
ssl.tmf.algorithm.not.supported=Error initializing trust manager factory (algorithm not supported).
ssl.tmf.init.failed=Error initializing trust manager factory (operation failed).
ssl.tmf.provider.not.registered=Error initializing trust manager factory (provider not registered).
stream.provider.null=Stream provider is not defined. It must be set before writing first bytes to the entity output stream.
string.is.null=String is null.
template.param.null=One or more of template keys or values are null.
thread.pool.executor.provider.closed=Thread pool executor provider has been closed.
too.many.header.values=Too many "{0}" header values: "{1}"
type.to.class.conversion.not.supported=Type-to-class conversion not supported for: {0}.
unable.to.parse.header.value=Unable to parse "{0}" header value: "{1}"
unhandled.exception.detected=Unhandled exception detected on thread {0}.
unknown.descriptor.type=Unable to register a service because of unknown descriptor type: {0}.
unknown.subscriber=Unknown subscriber.
uri.builder.scheme.part.null=Supplied scheme-specific part parameter is null.
uri.builder.scheme.part.unexpected.component=Supplied scheme-specific URI part "{0}" contains unexpected URI Scheme component: {1}.
uri.builder.uri.part.fragment=Supplied scheme-specific URI part "{0}" contains URI Fragment component: {1}.
uri.builder.class.path.annotation.missing=The class, {0} is not annotated with @Path.
uri.builder.methodname.not.specified=The method named "{0}" is not specified by {1}.
uri.builder.annotatedelement.path.annotation.missing=The annotated element "{0}" is not annotated with @Path.
uri.builder.schema.part.opaque=Schema specific part is opaque.
uri.component.encoded.octet.invalid.digit=Malformed percent-encoded octet at index {0}, invalid hexadecimal digit ''{1}''.
uri.component.encoded.octet.malformed=Malformed percent-encoded octet at index {0}.
uri.component.invalid.character=The string "{0}" for the URI component {1} contains an invalid character, ''{2}'', at index {3}.
uri.is.null=Uri is null.
uri.parser.component.delimiter=Component does not end by a delimiter ''{0}'' at index {1}.
uri.parser.not.executed=The parser was not executed yet. Call the parse() method first.
uri.parser.scheme.expected=Expected scheme name at index {0}: ''{1}''.
using.executor.provider=Selected ExecutorServiceProvider implementation [{0}] to be used for injection of executor qualified by [{1}] annotation.
using.scheduler.provider=Selected ScheduledExecutorServiceProvider implementation [{0}] to be used for injection of scheduler qualified by [{1}] annotation.
# {0} - Arbitrary localized message, e.g.: [FATAL] <localized_message>; source=<object>
warning.msg=WARNING: {0}
warning.provider.constrainedTo.wrong.package=A registered provider {0} constrained (via @ConstrainedTo) to {1} runtime implements interface {2} which is only usable in a {3} runtime context.
# {0} - List of arbitrary localized messages, e.g.: [FATAL] <localized_message>; source=<object>
warnings.detected=The following warnings have been detected: {0}
